module ParsePPM where

import Text.Parsec.Combinator
import Text.Parsec.Char
import Text.Parsec.ByteString
import Text.Parsec 
import Text.Parsec.Pos

import Control.Monad
import Data.Word
import Data.List.Split
 
data Pixel = Pixel { red :: Int, green :: Int, blue :: Int
                   } deriving (Show)
data BitMapFormat = BinaryBitMap | TextBitMap
data Header = Header { format :: BitMapFormat,
                width :: Int,
                height :: Int,
                depth :: Int
              }
data PPM = PPM { header :: Header,
             bitmap :: [Pixel]
           }

parseInteger :: (Read a, Integral a) => Parser a
parseInteger = fmap read (many1 digit)

parseHeader :: Parser Header
parseHeader = do
  f <- (string "P3" >> return TextBitMap) <|> (string "P6" >> return BinaryBitMap)
  w <- space >> parseInteger
  h <- space >> parseInteger
  d <- space >> parseInteger

  return (Header f w h d)

parseTextBitMap :: Header -> Parser [Pixel]
parseTextBitMap head = do
  raw <- count (3 * width head * height head) (spaces >> parseInteger)
  return (map (\[a, b, c] -> Pixel a b c) (chunksOf 3 raw))

parseByte :: Parser Int
parseByte = fmap fromEnum anyChar

parseBinaryBitMap :: Header -> Parser [Pixel]
parseBinaryBitMap head = do
  space
  raw <- count (3 * width head * height head) parseByte 
  return (map (\[a, b, c] -> Pixel a b c) (chunksOf 3 raw))

writeBitMap :: PPM -> IO ()
writeBitMap ppm = writeFile (magic ++ strWidth ++ strHeight ++ strDepth ++ pixData)
  where
    magic = if format (header ppm) == TexBitMap then "P3" else "P6"
    strWidth = show (width (header ppm)) ++ " "
    strHeight = show (height (header ppm)) ++ "\n"
    strDepth = show (depth (header ppm)) ++ "\n"
    sep = if format (header ppm) == TextBitMap then " " else ""
    writePixel = if format (header ppm) == TextBitMap then show else (\n -> [chr n])
  
